# Notes on Embedded System

### References

- [「組み込み」ならではの基礎知識　――スタートアップ・ルーチンからハードウェアまで](http://www.kumikomi.net/archives/2003/05/10kumi.php?page=1)

#### スタートアップルーチン

- `Windows` や `Linux/UNIX` の環境で C を使ってプログラミングするときは，`main 関数`以降をコーディングするが，プログラムは `main 関数`から始まっているのではない．その前段階として，`スタートアップ・ルーチン`というものが存在する

1. `電源が入ったり，リセット・ボタンが押される` = 「今の状態がどうあれ、`初期状態から動作せよ`」という強制的な指令（割り込み）= 組み込み機器が動き始める
2. マイコンはある`固定のアドレス`（`割り込みベクトル領域`と呼ばれる特別なメモリ領域のうち，`リセットに割り当てられたベクトル番地`）の内容を読み込む (そこに書かれている内容はマイコンによって異なり，`ジャンプ先のアドレス(1)`であったり，`短いプログラム(2)`であったりする)

- (1) そのアドレスに制御を移す
- (2) そこに書かれているプログラムを実行(実質的に、あるアドレスに制御を移すことと同じ)

3. `スタックの設定`、`プログラミの実行に必要なデータの設定`、`マイコンの動作モードの設定`、`ハードウェアの初期化`、`ハードウェアの自己診断`などの`スタートアップ・ルーチン`を行う
4. `main 関数`を呼び出す
5. `スタートアップ・ルーチン`に戻り、後処理を行うことが多い

- Windows や Linux/UNIX ではアプリケーションを開発するときにに`スタートアップ・ルーチン`を意識しなくても良い。これは、実行環境は常に同じ（毎回変更する必要がない）なので、C コンパイラが自動的に`スタートアップ・ルーチン`をリンクしているからである。（UNIX 系で言うと、`スタートアップ・ルーチン`は標準ライブラリといっしょに **`crt0.o`** と言う名前で存在する）

```text
・スタックの設定（変数のための RAM 領域）
・プログラムの実行に必要なデータの設定
　  ・ROM領域からRAM領域への初期値データの転送
　  ・初期値を持たないメモリ領域の0クリア
・マイコンの動作モードの設定
　  ・マイコン内蔵の周辺機能を使用するための各種レジスタの初期化
　  ・割り込み許可設定
・ハードウェアの初期化
・ハードウェアの自己診断
```

- プログラムの実行に必要なものとしては，スタック以外にも定数やグローバル変数がある．これらを初期化もしくは 0 クリアする必要がある．
- 定数の一部の値は ROM を参照して RAM にコピーしてやる必要があるかもしれない．それが，ROM 領域から RAM 領域への初期値データの転送．
- **`4`** ではスタートアップ・ルーチンから C プログラムの `main 関数`を直接呼び出すように書いてるが，C 言語の標準ライブラリを使用する場合は，`main 関数`を呼び出す前に`標準ライブラリの初期化`を実行する必要がある．そして，ソフトウェア自身の実行だけでなく`マイコンやそのほかのハードウェアを使用するための初期化`も必要になる（これらの初期化は，マイコンやハードウェアのマニュアルを参照しながらコーディングする）

#### 割り込み処理

- `割り込み信号`
  - `場合によっては受け付けなくても良い割り込み（マスク可能割り込み）`
  - `必ず受け付けなければならない割り込み（マスク不能割り込み）`
    - 割り込みを受け付けるとつごうの悪い処理を実行するときに，`あらかじめ割り込み禁止命令を実行`しておけば，`マスク可能割り込み`を受け付けないようにすることができる．処理が終わったら，`割り込み許可命令を実行することで，再び割り込みを受け付けるようになる`
- `多重割り込み`: 割り込み処理が複数あるときには優先順位をつける．優先順位の低い割り込み処理を実行している最中に，優先順位の高い割り込み処理を受け付けられるように作る
- `割り込み処理チェック・シート`

```text
設計チェック・シート
・事象にどのように対応するか
　 - 必ず受け付けなければならない？
　 - 受け付けそこねてもよい/そのうち検出できればよい？
・受け付けた事象について
　 - 直ちに処理しなければならない？
　 - 処理が遅れてもよい？
・受け付けて処理した後，元のしごとに戻る/戻らない？
・事象の発生頻度は？
・処理速度を上回るしごとが入る可能性は？
・処理時間を見積もったか？また実機を使って計測できるか？
・設計マージンはあるか？
・スタックは見積もったか？多重呼び出しされたサブルーチンに割り込みが入ったとき，あふれないか？
```

#### エッジ・トリガ/ レベル・センス

- `レベル・センス`: ディジタル回路では、あるしきい値（`スレッショルド`）以上の電圧をハイ（`H`）レベル、あるしきい値以下の電圧をロー（`L`）レベルと言い、それぞれのレベルを検出することを`レベル・センス`と言う
- `"L"`レベルを「有効」であるとする使いかたを`アクティブL`，`H`レベルを「有効」であるとする使いかたを`アクティブH` と言う
- `CMOS 論理回路`では`アクティブL`が常用される
  - その理由は，`L`のときの出力が`H`のときの出力よりも大きいことや，入力回路で`プルアップ抵抗`（標準レベルを`H`にするための抵抗）が付いていると`L`になったときだけ電流が流れて節電になることなど，メリットが多いため
- `信号波形`における信号の変わり目を`エッジ`と呼ぶ
  - `立ち下がりエッジ`: `H`レベルから`L`レベルに変わるところ
  - `立ち上がりエッジ`: `L`レベルから`H`レベルに変わるところ
  - `エッジ・トリガ`: このエッジをある動作の引き金にすること

#### CPU と デブバイスはどうつながっているか

-> CPU とデバイスは，`リード信号線`，`ライト信号線`，`データ・バス`，`アドレス・バス`を使って接続される

- `アドレス空間`: CPU がアクセスできる場所の総称．（アドレス空間は論理的な世界です）
- CPU には，メモリをつなぐための空間（メモリ空間）のほかに `I/O` をつなぐための空間（`I/O 空間`）を持つものと，`I/O 空間`を持たないものの 2 通りがある．
- `メモリ・マップド I/O`・`メモリ・マップ方式の I/O`: `I/O`空間を持たない CPU では，メモリ空間に`I/O` を配置
- `アドレス・バス`: 場所を指定するために使う信号線
- `データ・バス`: 場所の内容をやりとりするために使う信号線
- `アドレス空間の大きさ`は，`アドレス・バス`が何本の信号線から構成されているかによって決まる．
  - `アドレス・バス`に `n` 本の線があれば，`2^n` ヵ所の番地にアクセスできまる．例えば，16 本あれば 2^16 で 65,536 番地，32 本あれば 2^32 ＝ 4× 1,024×1,024×1,024 で，4G（ギガ）番地分に対してアクセスできる
- `一つの番地とやりとりできるデータ量`は，データ・バスの信号線の本数を上限とした大きさになる．データ・バスに m 本の線があれば，m ビットの情報を一つの番地と 1 回でやりとりできる
- CPU がデバイスから情報を読み出すときは`リード信号`を`有効`に、CPU がデバイスに情報を書き込むときは`ライト信号`を`有効`にする
- `メモリ空間にアクセスする`ためには，`メモリ・アクセス命令`を使う．`メモリ・アクセス命令`には，メモリの内容を読み出す`リード命令`，メモリに書き込む`ライト命令`という 2 種類の命令があり，それぞれの命令に応じて，`リード信号`，`ライト信号`が有効になる．

##### CPU によるデバイスの読み書きのタイミング

- 読み込み: デバイスからデータを読み出すときは，CPU がアドレス・バスに読みたい番地を出力し，リード信号を有効にする．指定された番地の内容をデバイスがデータ・バスに置く．CPU は，リード信号線の立ち上がりタイミングで，データ・バスの内容を取り込む．
- 書き込み: デバイスにデータを書き込むときは，CPU がアドレス・バスに書き込む番地を出力し，データ・バスに書き込むデータを置いて，ライト信号を有効にする．デバイスは，ライト信号の立ち上がりでデータ・バスの内容を取り込む．

#### 値を保持するラッチと出入りを仕切るゲート

- 注意が必要なのは，`データ・バスに有効なデータが載っているの`は，`リード信号やライト信号が有効な間だけ`であること．
- `ある番地のポートに書き込んだ値を保持したい`ときは，`ラッチ`と呼ばれるデバイスを取り付ける．
  - ラッチはあらかじめ決められた番地に書き込まれた値を保持してその出力の状態を保つ．（LED などをこのラッチの出力につなぐことで，点灯/消灯状態を保つことができる）
- `メモリマップ`・`I/O マップ`: 番地とそれに対応する周辺装置，デバイス，入出力の種別，値の意味が記述されている表

#### Columns

> 便利な道具の代表選手はスクリプト言語でしょう．UNIX の C シェルに始まり，Perl や Python など，いろいろあります．自分は C 言語が得意だからといって，データ整理のためのプログラムをすべて C 言語で書くというのは効率が悪いことです．目的に合った道具を箱から取り出して，涼しい顔でデータ処理を片づけてしまう，このような技術者になってもらいたいと思います．データ処理のような単純作業を手作業で延々とやっているようでは技術者とは言えません．そのためには，日ごろからいろいろな道具を好奇心を持って使ってみることです．

> 本を読み続けよう: 会社で業務としてしごとをするだけでは知識が偏ってしまいます．本を読んで，しごとに直結する応用面だけでなく，関連知識を含めて基礎から学びましょう
