### メモリアロケーション (メモリ確保, メモリ割り当て)

- `メモリ割り当て`の種別
  - `静的メモリ割り当て`: プログラムを実行するとき `外部変数（global variable、関数の外で定義される変数、永久に存在する変数）` 、`コード（プログラムの基本となる制御部分）`をあるメモリ領域（データ領域）に確保する（定数は ROM (read only memory) に格納される）
  - `自動メモリ割り当て`: `局所変数` や `関数の引数` は `スタック領域` に確保（変数は RAM (random access memory) に格納される）
  - `動的メモリ割り当て`: `ヒープ領域` からメモリを割り当てる
    - ヒープ領域からメモリを取得する関数 `malloc` が標準ライプらりに用意されている。`malloc` で割り当てたメモリ領域は、`局所変数`や`引数`のように自動的に解放**されない**。メモリを解放するための関数が　　 `free`

```c
// sample1
int fact(int n)
{
  if (n === 0){
    return 1;
  } else {
    return n fact(n - 1);
  }
}
int main(void)
{
  fact(4);
}
```

- `sample1` の場合スタックポインタ（SP、レジスタ）は次のような状態になっている
- まず引数 n の値３がスタックに積まれる（I）SP は一つ減る。（このように、関数呼び出しが行われるたびに引数が新しい領域にコピーされていく。これが `値呼び` の仕組み）
- その次に fact の関数呼び出しが行われる。関数を呼び出す場合、呼び出された関数から`呼び出し元の関数に戻るための情報`（`リターンアドレス`、または`ベース・アドレス`とも言う）をスタックにプッシュする

```text
Address Low A []
            B [ リターンアドレス ]
            C [ 引数 n : 0     ]
            D [ リターンアドレス ]
            E [ 引数 n : 1     ]
            F [ リターンアドレス ]
            G [ 引数 n : 2     ]
            H [ リターンアドレス ]
            I [ 引数 n : 3     ]
       High J [               ]
```

- 今着目している変数部のいちばん下の番地を格納するポインタ（これを`フレーム・ポインタ(FP)`と呼ぶ）を作成することで、このフレーム・ポインタからの相対位置（フレーム・ポインタからデータまでのオフセット）を利用してアクセスするようにします．処理が完了したら、FP の位置をひとつ前に戻し、SP をリターンアドレスまで戻ることで元の呼び出し側の関数に戻ることができる（SP が戻る時に、局所変数も POP されてそのメモリが解放される）

- CPU が x86 の場合、実引数は右側から順番にスタックに積まれていく（`sample2`）

```text
// sample2
// has_three_args(1, 2, 3);
// 引数をスタックに積順（CPU が x86 の場合）

Address Low [   ]  [   ]  [   ]
            [   ]  [   ]  [ 1 ]
            [   ]  [ 2 ]  [ 2 ]
            [ 3 ]  [ 3 ]  [ 3 ]
       High [   ]  [   ]  [   ]
```
