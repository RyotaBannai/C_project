### メモリアロケーション (メモリ確保, メモリ割り当て)

- `メモリ割り当て`の種別
  - `静的メモリ割り当て`: プログラムを実行するとき `外部変数（global variable、関数の外で定義される変数、永久に存在する変数）` をあるメモリ領域（データ領域）に確保する
  - `自動メモリ割り当て`: `局所変数` や `関数の引数` は `スタック領域` に確保
  - `動的メモリ割り当て`: `ヒープ領域` からメモリを割り当てる
    - ヒープ領域からメモリを取得する関数 `malloc` が標準ライプらりに用意されている。`malloc` で割り当てたメモリ領域は、`局所変数`や`引数`のように自動的に解放**されない**。メモリを解放するための関数が　　 `free`

```c
// sampel1
int fact(int n)
{
  if (n === 0){
    return 1;
  } else {
    return n fact(n - 1);
  }
}
int main(void)
{
  fact(4);
}
```

- `sampel1` の場合スタックポインタ（SP）は次のような状態になっている
- まず引数 n の値３がスタックに積まれる（I）SP は一つ減る。（このように、関数呼び出しが行われるたびに引数が新しい領域にコピーされていく。これが `値呼び` の仕組み）
- その次に fact の関数呼び出しが行われる。関数を呼び出す場合、呼び出された関数から`呼び出し元の関数に戻るための情報`（`リターンアドレス`）をスタックにプッシュする

```text
Address Low A []
            B [ リターンアドレス ]
            C [ 引数 n : 0     ]
            D [ リターンアドレス ]
            E [ 引数 n : 1     ]
            F [ リターンアドレス ]
            G [ 引数 n : 2     ]
            H [ リターンアドレス ]
            I [ 引数 n : 3     ]
       High J [               ]
```

- CPU が x86 の場合、実引数は右側から順番にスタックに積まれていく（`sample2`）

```text
// sample2
// has_three_args(1, 2, 3);
// 引数をスタックに積順（CPU が x86 の場合）

Address Low [   ]  [   ]  [   ]
            [   ]  [   ]  [ 1 ]
            [   ]  [ 2 ]  [ 2 ]
            [ 3 ]  [ 3 ]  [ 3 ]
       High [   ]  [   ]  [   ]
```
