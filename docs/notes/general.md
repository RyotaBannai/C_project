### メモリアロケーション (メモリ確保, メモリ割り当て)

- `メモリ割り当て`の種別
  - `静的メモリ割り当て`: プログラムを実行するとき `外部変数（global variable、関数の外で定義される変数、永久に存在する変数）` 、`コード（プログラムの基本となる制御部分）`をあるメモリ領域（データ領域）に確保する（定数は ROM (read only memory) に格納される）
  - `自動メモリ割り当て`: `局所変数` や `関数の引数` は `スタック領域` に確保（変数は RAM (random access memory) に格納される）
  - `動的メモリ割り当て`: `ヒープ領域` からメモリを割り当てる
    - ヒープ領域からメモリを取得する関数 `malloc` が標準ライプらりに用意されている。`malloc` で割り当てたメモリ領域は、`局所変数`や`引数`のように自動的に解放**されない**。メモリを解放するための関数が　　 `free`

```c
// sample1
int fact(int n)
{
  if (n === 0){
    return 1;
  } else {
    return n fact(n - 1);
  }
}
int main(void)
{
  fact(4);
}
```

- `sample1` の場合スタックポインタ（SP、レジスタ）は次のような状態になっている
- まず引数 n の値３がスタックに積まれる（I）SP は一つ減る。（このように、関数呼び出しが行われるたびに引数が新しい領域にコピーされていく。これが `値呼び` の仕組み）
- その次に fact の関数呼び出しが行われる。関数を呼び出す場合、呼び出された関数から`呼び出し元の関数に戻るための情報`（`リターンアドレス`、または`ベース・アドレス`とも言う）をスタックにプッシュする

```text
Address Low A []
            B [ リターンアドレス ]
            C [ 引数 n : 0     ]
            D [ リターンアドレス ]
            E [ 引数 n : 1     ]
            F [ リターンアドレス ]
            G [ 引数 n : 2     ]
            H [ リターンアドレス ]
            I [ 引数 n : 3     ]
       High J [               ]
```

- 今着目している変数部のいちばん下の番地を格納するポインタ（これを`フレーム・ポインタ(FP)`と呼ぶ）を作成することで、このフレーム・ポインタからの相対位置（フレーム・ポインタからデータまでのオフセット）を利用してアクセスするようにします．処理が完了したら、FP の位置をひとつ前に戻し、SP をリターンアドレスまで戻ることで元の呼び出し側の関数に戻ることができる（SP が戻る時に、局所変数も POP されてそのメモリが解放される）

- CPU が x86 の場合、実引数は右側から順番にスタックに積まれていく（`sample2`）

```text
// sample2
// has_three_args(1, 2, 3);
// 引数をスタックに積順（CPU が x86 の場合）

Address Low [   ]  [   ]  [   ]
            [   ]  [   ]  [ 1 ]
            [   ]  [ 2 ]  [ 2 ]
            [ 3 ]  [ 3 ]  [ 3 ]
       High [   ]  [   ]  [   ]
```

#### Array[-1] はなぜ動作するか

- メモリ空間の特定のアドレス（先頭のアドレス）とオフセットから計算される。
- (array の先頭アドレスが`0x1020 番地`の場合、`array[0]`は `0x1020 番地`，`array[1]`は `0x1024 番地`(`0x1020 + 1 * sizeof(int)`)，`array[2]`は `0x1028 番地`(`0x1020 + 2 * sizeof(int)`)，...ととなる（と計算される）)
- -> つまり、配列を利用するには`メモリ空間上の連続した場所があれば良い`わけである
- -> つまり、`array[-1]` が動作する理由は先頭アドレスの前にオフセットを戻して参照するため動作するからである（プログラムの挙動がおかしい時は配列のインデックスが負になっているかもしれない）

- ポインタは`先頭アドレス`に加え、配列の`型情報`も持ち合わせる。例えば以下の例では、配列 p は array の先頭を指し示すポインタで、そのポインタの示すアドレスの中身は int 型である。

```c
int *p = array;
```

- つまり`配列`の実態は **`型情報をもった配列の先頭のアドレスを指し示すポインタ`** である

```c
int *p = (int *)0x1020; /* これは int *p = array; と同じ*/
```

- 上記の右辺は`(int *)`のキャストで型情報がついたポインタ（つまり，アドレス 0x1020 でその内容は int であるポインタ）（普通の C 言語のプログラムでは式このような表現を使わないが，組み込みプログラムでは`周辺 I/O` をアクセスするための`レジスタ操作のため`に日常的に使う）

#### Volatile

> volatile の目的は，`黙っていると処理系で行われる最適化を抑止すること`にある．例えば，`メモリ・マップ方式の入出力をもつマシン`では，`ステータス・レジスタに対するポインタ`は，`ポインタによる見かけ上，冗長な参照`をコンパイラが除去するのを防ぐのに，`volatile へのポインタと宣言する`ことが可能である．

- `C コンパイラの最適化を抑止しなければならない理由`:
  - `見かけ上、助長な参照`:
    - 例えば、`シリアルインターフェースを使ったデータの受信`を考えてみる:
      - `メモリ・マップ方式のシリアル・ポートを持つマイコン`の場合、`受信状態を表すレジスタ`（`ステータス・レジスタ`）を読み出せば、`そのシリアル・インターフェース経由でデータを受け取ったかどうか`がわかる
      - レジスタを読み出す方法：メモリ・マップ方式の場合は、一つのレジスタに対してあるアドレスが割り当てられるため、そのアドレスの内容を読みだせば良い。
      - 例えば受信状態を表すレジスタのアドレスを `0x00efd00c` 番地、レジスタの長さを 4 バイトと仮定すると、受信状態を表すレジスタの読みだしは、`*(unsigned long int *)(0x00efd00c)` となる。
      - いつ受信するかわからないので、`while(1)` でループして（ポーリング方式）レジスタをチェックすることにすると以下のようなコードになる → その下のコードのようなコンパイラの最適化のパターンにハマってしまう
  - `volatile 宣言`をする: その次の例のように `volatile` をつけることで C コンパイラに夜最適は行われず、意図しているように動くようになる
    - volatile を付けたデータの値が要求されると，`前に同じデータの値が要求されていたとしてもその値を使わず`に，`その時点のデータの値を必ず読み取るようなコード`が生成される
    - 「直前の同じデータの値を使わずに，その時点のデータの値を読み取る」:「データに書き込まれた値はすぐに消えてしまうので，必要となった時点のデータの値を読み取る」こと

```c

// intent 「見かけ上，冗長」
while (1) {
  if (((*(unsigned long int *)(0x00efd00c))&4) != 0) {
    /* 受信したので処理を実行 */
  }
}

// optimized
if (((*(unsigned long int *)(0x00efd00c))&4) != 0) {
  while (1) {
    ...
  }
}
// → レジスタを読みに行く最初の1回で受信完了になっていないと，永遠にデータを受信できない
```

```c
while (1) {
  if (((*(volatile unsigned long int *)(0x00efd00c))&4) != 0) {
    ...
  }
}
```

#### 割り込み処理

- `割り込み信号`
  - `場合によっては受け付けなくても良い割り込み（マスク可能割り込み）`
  - `必ず植え付けなければならない割り込み（マスク不能割り込み）`
    - 割り込みを受け付けるとつごうの悪い処理を実行するときに，`あらかじめ割り込み禁止命令を実行`しておけば，`マスク可能割り込み`を受け付けないようにすることができる．処理が終わったら，`割り込み許可命令を実行することで，再び割り込みを受け付けるようになる`
- `多重割り込み`: 割り込み処理が複数あるときには優先順位をつける．優先順位の低い割り込み処理を実行している最中に，優先順位の高い割り込み処理を受け付けられるように作る
- `割り込み処理チェック・シート`

```text
設計チェック・シート
・事象にどのように対応するか
　 - 必ず受け付けなければならない？
　 - 受け付けそこねてもよい/そのうち検出できればよい？
・受け付けた事象について
　 - 直ちに処理しなければならない？
　 - 処理が遅れてもよい？
・受け付けて処理した後，元のしごとに戻る/戻らない？
・事象の発生頻度は？
・処理速度を上回るしごとが入る可能性は？
・処理時間を見積もったか？また実機を使って計測できるか？
・設計マージンはあるか？
・スタックは見積もったか？多重呼び出しされたサブルーチンに割り込みが入ったとき，あふれないか？
```
