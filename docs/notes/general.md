### References

- [メモリアロケーション](http://www.nct9.ne.jp/m_hiroi/linux/clang08.html)

### メモリアロケーション (メモリ確保, メモリ割り当て)

- `メモリ割り当て`の種別
  - `静的メモリ割り当て`: プログラムを実行するとき `外部変数（global variable、関数の外で定義される変数、永久に存在する変数）` 、`コード（プログラムの基本となる制御部分）`をあるメモリ領域（`データ領域`）に確保する（定数は ROM (read only memory) に格納される）
  - `自動メモリ割り当て`: `局所変数` や `関数の引数` は `スタック領域` に確保（変数は RAM (random access memory) に格納される）
  - `動的メモリ割り当て`: `ヒープ領域` からメモリを割り当てる
    - ヒープ領域からメモリを取得する関数 `malloc` が標準ライプらりに用意されている。`malloc` で割り当てたメモリ領域は、`局所変数`や`引数`のように自動的に解放**されない**。メモリを解放するための関数が　　 `free`

```c
// sample1
int fact(int n)
{
  if (n === 0){
    return 1;
  } else {
    return n fact(n - 1);
  }
}
int main(void)
{
  fact(4);
}
```

- `sample1` の場合スタックポインタ（SP、`レジスタ`）は次のような状態になっている
- まず引数 n の値３がスタックに積まれる（I）SP は一つ減る。（このように、関数呼び出しが行われるたびに引数が新しい領域にコピーされていく。これが `値呼び` の仕組み）
- その次に fact の関数呼び出しが行われる。関数を呼び出す場合、呼び出された関数から`呼び出し元の関数に戻るための情報`（`リターンアドレス`、または`ベース・アドレス`とも言う）をスタックにプッシュする

```text
Address Low A []
            B [ リターンアドレス ]
            C [ 引数 n : 0     ]
            D [ リターンアドレス ]
            E [ 引数 n : 1     ]
            F [ リターンアドレス ]
            G [ 引数 n : 2     ]
            H [ リターンアドレス ]
            I [ 引数 n : 3     ]
       High J [               ]
```

- 今着目している変数部のいちばん下の番地を格納するポインタ（これを`フレーム・ポインタ(FP)`と呼ぶ）を作成することで、このフレーム・ポインタからの相対位置（フレーム・ポインタからデータまでのオフセット）を利用してアクセスするようにします．処理が完了したら、FP の位置をひとつ前に戻し、SP をリターンアドレスまで戻ることで元の呼び出し側の関数に戻ることができる（SP が戻る時に、局所変数も POP されてそのメモリが解放される）
- なお、コンパイラの最適化によっては、局所変数はスタック上に確保されるのではなく、`レジスタ`に割り当てられる場合がある

  - `レジスタ`は CPU 内部にある`一時記憶メモリのこと`で、CPU の外部に接続されているメモリ（主記憶メモリ）とは異なる
  - 一般に、`レジスタ`は`メモリよりも高速にアクセスすることができる`ので、局所変数をスタック上に作るよりも`レジスタ`に割り当てたほうが、`プログラムを高速に実行することができる`

- CPU が x86 の場合、実引数は右側から順番にスタックに積まれていく（`sample2`）

```text
// sample2
// has_three_args(1, 2, 3);
// 引数をスタックに積順（CPU が x86 の場合）

Address Low [   ]  [   ]  [   ]
            [   ]  [   ]  [ 1 ]
            [   ]  [ 2 ]  [ 2 ]
            [ 3 ]  [ 3 ]  [ 3 ]
       High [   ]  [   ]  [   ]
```

#### Array[-1] はなぜ動作するか

- メモリ空間の特定のアドレス（先頭のアドレス）とオフセットから計算される。
- (array の先頭アドレスが`0x1020 番地`の場合、`array[0]`は `0x1020 番地`，`array[1]`は `0x1024 番地`(`0x1020 + 1 * sizeof(int)`)，`array[2]`は `0x1028 番地`(`0x1020 + 2 * sizeof(int)`)，...ととなる（と計算される）)
- -> つまり、配列を利用するには`メモリ空間上の連続した場所があれば良い`わけである
- -> つまり、`array[-1]` が動作する理由は先頭アドレスの前にオフセットを戻して参照するため動作するからである（プログラムの挙動がおかしい時は配列のインデックスが負になっているかもしれない）

- ポインタは`先頭アドレス`に加え、配列の`型情報`も持ち合わせる。例えば以下の例では、配列 p は array の先頭を指し示すポインタで、そのポインタの示すアドレスの中身は int 型である。

```c
int *p = array;
```

- つまり`配列`の実態は **`型情報をもった配列の先頭のアドレスを指し示すポインタ`** である

```c
int *p = (int *)0x1020; /* これは int *p = array; と同じ*/
```

- 上記の右辺は`(int *)`のキャストで型情報がついたポインタ（つまり，アドレス 0x1020 でその内容は int であるポインタ）（普通の C 言語のプログラムでは式このような表現を使わないが，組み込みプログラムでは`周辺 I/O` をアクセスするための`レジスタ操作のため`に日常的に使う）

#### Volatile

> volatile の目的は，`黙っていると処理系で行われる最適化を抑止すること`にある．例えば，`メモリ・マップ方式の入出力をもつマシン`では，`ステータス・レジスタに対するポインタ`は，`ポインタによる見かけ上，冗長な参照`をコンパイラが除去するのを防ぐのに，`volatile へのポインタと宣言する`ことが可能である．

- `C コンパイラの最適化を抑止しなければならない理由`:
  - `見かけ上、助長な参照`:
    - 例えば、`シリアルインターフェースを使ったデータの受信`を考えてみる:
      - `メモリ・マップ方式のシリアル・ポートを持つマイコン`の場合、`受信状態を表すレジスタ`（`ステータス・レジスタ`）を読み出せば、`そのシリアル・インターフェース経由でデータを受け取ったかどうか`がわかる
      - レジスタを読み出す方法：メモリ・マップ方式の場合は、一つのレジスタに対してあるアドレスが割り当てられるため、そのアドレスの内容を読みだせば良い。
      - 例えば受信状態を表すレジスタのアドレスを `0x00efd00c` 番地、レジスタの長さを 4 バイトと仮定すると、受信状態を表すレジスタの読みだしは、`*(unsigned long int *)(0x00efd00c)` となる。
      - いつ受信するかわからないので、`while(1)` でループして（ポーリング方式）レジスタをチェックすることにすると以下のようなコードになる → その下のコードのようなコンパイラの最適化のパターンにハマってしまう
  - `volatile 宣言`をする: その次の例のように `volatile` をつけることで C コンパイラに夜最適は行われず、意図しているように動くようになる
    - volatile を付けたデータの値が要求されると，`前に同じデータの値が要求されていたとしてもその値を使わず`に，`その時点のデータの値を必ず読み取るようなコード`が生成される
    - 「直前の同じデータの値を使わずに，その時点のデータの値を読み取る」:「データに書き込まれた値はすぐに消えてしまうので，必要となった時点のデータの値を読み取る」こと

```c

// intent 「見かけ上，冗長」
while (1) {
  if (((*(unsigned long int *)(0x00efd00c))&4) != 0) {
    /* 受信したので処理を実行 */
  }
}

// optimized
if (((*(unsigned long int *)(0x00efd00c))&4) != 0) {
  while (1) {
    ...
  }
}
// → レジスタを読みに行く最初の1回で受信完了になっていないと，永遠にデータを受信できない
```

```c
while (1) {
  if (((*(volatile unsigned long int *)(0x00efd00c))&4) != 0) {
    ...
  }
}
```

#### Pointer

- `配列による文字列`: `char str[] = "ABC";`、`ポインタによる文字列`: `char *str = "ABC` どちらも同じような性質であるが、配列による文字列は占有するバイト数は sizeof(str) == 4 ("ABC" + '\0') に対し、ポインタによる文字列は、sizeof(str) == 4 + pointer 分(char 型であればその配列の先頭になるので 1)
- `文字列リテラル`は`静的記憶域期間`を持つため、pointer からの参照がなくなっても記憶域から自動的に破棄される、と言ったことは**ない**。

- c++ でも `call by reference` がサポートされている
- 呼び出し側では、`&` 関数に渡すときにはアドレス演算子（`address operator`/ `参照演算子`）を使わずにそのまま渡すが、呼び出される側は `Type&` のように `&` を型の後ろに付け加える。（c の場合は変数の前にアスタリスク `*`（`indirection operator`/ `間接演算子`）をつける ）

```c++
#include <iostream>

using namespace std;
void increment(int& no){
  ++no;
}

int main(void){
  int x = 5;
  increment(x);
  coun << "the x value is" << x << '\n';
  return 0;
}
```

- `void pointer`: NULL pointer とは意味が違って、c lang では、pointer の generic 意味で使われる。例えば、`calloc`, `malloc`, `realloc` では特定の型への pointer に依存するとまずいので　 void pointer （void \*） とするとこでどの型のポインターでも受け付ける、または、返却するとこができるようになっている。(c++ では、明示的にキャストしなければならない。これは、ポインタをキャストすることによって値が変化してしまう危険性があるため。)
- `calloc`, `malloc` が確保するのは、特定の型のオブジェクトではなく、単なる記憶行きの "かたまり"（`raw memory`）である. (c++ でのオブジェクトの生成と解放は演算子で行えるようになっている。`int* x = new int; # 生成` `delete x; # 解放`)

#### \* interpretation.

- `**(b+i)` evaluates to: `b[i][0]` because...
  1. `**(b+i)` is equivalent to: `*(*(b+i)+0)`, and since
  2. `*(b+i)` is equivalent to `b[i]`, the expression as a whole can be seen as:
  3. `*(b[i]+0)`, and hence: `b[i][0]`
- `*(a+b) is identical to a[b]`(2.), and `*a is equivalent to *(a+0)`(1.)

#### string literal について

- c lang では `string 型`はなく文字列を表現するときは、`char 型の配列`（または `char *`）であるため、char `*s = 'A'` とすると、先頭の文字を書き換えることができる。これに対して、
- c++ では `const char 型の配列`になるため、書き換えが禁止されている。
- golang でも `string 型`は immutable であるため書き換えが不可であり、書き換える場合は一度 `rune 型`に変換してからインデックスを指定し再代入することになる（それから `string 型`で再キャストする）。（`my_runes := []rune(my_string)` -> `my_runes[0] = 'A'` -> `string(my_runes)`）

#### stream

- `fclose(FILE *stream)`:
  - stream が指す stream をフラッシュする。
  - stream にバッファリングされて書き込みがまだのデータはホスト環境に引き渡し、ホスト環境がデータを書き込む。
  - stream にバッファリングされて読み込みもまだの場合そのデータを捨てる。
  - また、自動的にストリームにバッファが割り当てられていた場合に限り、そのバッファを自動で解放する
- テキストストリームの場合、読み込んだテキストと実際のテキストが完全に一致する保証はない（`ストリーム内の文字`と`外部表現の文字`との間で、１対１の対応があるとは限らない）
  - 例えば MS-Windows 環境では、改行文字をプログラム内部では 1 バイトで表現するのに対し、大部のファイルでは 2 バイトで表現する。
  - `ストリーム`として読みとったデータと`外部（テキストなど）`の読み取られるデータを比較して、一致することが保証されるためには、次の３つの条件を全て満たされなければならない:
    - データが`表示文字`と`制御文字である水平タブ/ 改行`**だけ**で構成される
    - 改行文字の前に空白文字が**無い** (改行文字の直前の空白文字を無視するかどうかは処理系依存なため)
    - 最後の文字が改行もである
- バイナリストリームは、同一の処理系の元で書き出したバイナリデータを読み込むときは一致していなければならない、という制限がある。ただし、ストリームの最後になる文字を処理系定義の個数だけ付加することは許されている。

#### byte order

- `network byte order`: 4 バイト長の IP アドレスと、2 バイト長のポート番号は `big endian` でその数値を記述しなくてはいけない決まり。これはたとえ同じ種類の マシン間で通信する場合でも従わなくてはいけない。
- 例えば IP アドレス `"127.0.0.1"` を long 型変数に設定するには `big endian` のマシンでは

```c++
unsigned long ip = 0x7f000001;
```

とするが、`little endian` のマシンでは

```c++
unsigned long ip = 0x0100007f;
```

とする。しかしマシンによって整数定数の表現が変わるのはプログラマにとって大変面倒であるため、次のようにする：

```c++
unsigned long ip = htonl(0x7f000001);
```

`htonl` 関数は long 型の値を host でのメモリ扱い方法を network の世界での方法 (network byte order = big endian) に、必要があれば変換する。 なので、これでどのマシンでも自動的に big endian として 変数に値を代入できる。
同様に short 型の値であるポート番号は `htons` 関数で big endian に統一する。

```c++
unsigned short port = htons(80);
```

逆に network order を host order に戻す `ntohl`, `ntohs` 関数もある。

```c++
printf("IP = %08x PORT=%u", ntohl(ip), ntohs(port) );
```
